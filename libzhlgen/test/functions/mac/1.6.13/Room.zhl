// Continue from RockAnimation::GetShootingSound (hyper efficiencyâ„¢)
"!.554889e54157415641554154534881eca801":
cleanup __amd64 void Room::constructor(Room *this, int _iShipId, int _x, int _y, int _w, int _h, int _roomId);
"!.554889e5f30f1187f4":
cleanup __amd64 void Room::SetHacked(Room *this, float val);
"!.554889e541574156":
cleanup __amd64 void Room::destructor(Room *this);
".554889e585f678":
cleanup __amd64 void Room::SetPrimarySlot(Room *this, int slot);
".554889e5":
cleanup __amd64 int Room::GetEmptySlots(Room *this, bool intruder);
".554889e5":
cleanup __amd64 bool Room::Full(Room *this, bool intruder);
".554889e5":
cleanup __amd64 bool Room::Empty(Room *this, bool intruder);
".554889e5":
cleanup __amd64 int Room::GetEmptySlot(Room *this, bool intruder);
".554889e5":
cleanup __amd64 int Room::EmptySlot(Room *this, int slot, bool intruder);
".554889e5":
cleanup __amd64 void Room::FillSlot(Room *this, int slot, bool intruder);
".554889e541574156415541545350":
cleanup __amd64 void Room::OnLoop(Room *this);
"!.554889e5f30f100d":
cleanup __amd64 void Room::OnRenderFloor(Room *this, float alpha, bool experimental);
"!.554889e553504889fb807b68":
cleanup __amd64 void Room::OnRenderWalls(Room *this, float alpha);


struct Room depends (Globals, Point) 
{{
	Room(int iShipId, int x, int y, int w, int h, int roomId)
	{
		this->constructor(iShipId, x, y, w, h, roomId);
	}

	~Room()
	{
		this->destructor();
	}

	Point GetIntoRoom(Point position)
	{
		int posX = position.x;
		int posY = position.y;

		int rectY = this->rect.y;
		int rectH = this->rect.h;

		int rectX = this->rect.x;
		int rectW = this->rect.w;

		//printf("%d %d %d %d %d %d\n", posX, posY, rectX, rectW, rectY, rectH);

		if (rectY + rectH - posY > 15 && posY - rectY > 15)
		{
			if (rectW + rectX - posX > 15 && posX - rectX > 15)
			{
				return Point(-1, -1);
			}
		}

		Point center = Point(rectX + rectW / 2, rectY + rectH / 2);

		Point toGrid = Point((posX + 2 * (center.x > posX) - 1) / 35, (posY + 2 * (center.y > posY) - 1) / 35);
		Point fromGrid = Point(toGrid.x * 35, toGrid.y * 35);

		return Point(fromGrid.x + 17, fromGrid.y + 17);
	}

	inline Globals::Rect GetRect()
	{
		return this->rect;
	}

	bool ContainsPoint(int x, int y, bool bIncludeWalls)
	{
		if (bIncludeWalls)
		{
			if ((x >= rect.x) && (x <= rect.x + rect.w) && (y >= rect.y))
			{
				return y <= (rect.y + rect.h);
			}
		}
		else
		{
			if ((x > rect.x) && (x < rect.x + rect.w) && (y > rect.y))
			{
				return y < (rect.y + rect.h);
			}
		}

		return false;
	}
}};
