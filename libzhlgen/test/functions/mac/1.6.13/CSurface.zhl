// Continue from CFPS::GetSpeedFactor (hyper efficiencyâ„¢)
/*
"554889e5e8????0b0085c00f95c05dc3":
static cleanup __amd64 bool CSurface::IsFrameBufferSupported();
"!.554889e5e8f79800005de9????0b00":
static cleanup __amd64 void CSurface::StartFrame();
*/
"!.554889e55de9????0b00":
static cleanup __amd64 void CSurface::FinishFrame();
"!.554889e5f3x":
static cleanup __amd64 void CSurface::GL_ClearAll();
"!.554889e50f":
static cleanup __amd64 void CSurface::GL_ClearColor();
".554889e5e8????????b0":
static cleanup __amd64 int CSurface::SetViewPort(int left, int bottom, int h, int w);
".554889e54883ec1089":
static cleanup __amd64 int CSurface::GL_PushScissor(int x, int y, int h, int w);
"!.554889e5488b05??????00488b35":
static cleanup __amd64 void CSurface::GL_PopScissor();
"!.554889e5415653":
static cleanup __amd64 void CSurface::GL_SetStencilMode(GL_StencilMode stencilMode, int ref, int mask);
"!.554889e54157":
static cleanup __amd64 void CSurface::GL_PushStencilMode();
"!.554889e5488b05":
static cleanup __amd64 void CSurface::GL_PopStencilMode();
"!.554889e55d":
static cleanup __amd64 int CSurface::GL_OrthoProjection(float mx1, float mx2, float mx3, float mx4, float mx5, float mx6);
"!.554889e5488d05":
static cleanup __amd64 int CSurface::GL_LoadIdentity();
".8b05??????004883":
static cleanup __amd64 int CSurface::GL_PushMatrix();
"!.554889e58b":
static cleanup __amd64 int CSurface::GL_PopMatrix();
".0f57e40f":
static cleanup __amd64 void CSurface::GL_Rotate(float angle, float x, float y, float z=1.f);
"!.554889e50f2e05":
static cleanup __amd64 void CSurface::GL_Scale(float x, float y, float z);
"!.554889e50f57e40f":
static cleanup __amd64 bool CSurface::GL_Translate(float x, float y, float z=0.f);
".554889e54883ec10f3":
static cleanup __amd64 int CSurface::GL_SetColor(GL_Color color);
".554889e50f2805??????00f2":
static cleanup __amd64 GL_Color CSurface::GL_GetColor();
".554889e54883ec100f1345f0":
static cleanup __amd64 void CSurface::GL_SetColorTint(GL_Color color);
".554889e5488b05??????00483905":
static cleanup __amd64 void CSurface::GL_RemoveColorTint();
".554889e5488b05??????00483905":
static cleanup __amd64 GL_Color CSurface::GetColorTint();
"!.554889e5bf01000000be0300":
static cleanup __amd64 bool CSurface::GL_EnableBlend();
"!.554889e5bf01000000be0100000031d25d":
static cleanup __amd64 bool CSurface::GL_DisableBlend();
".554889e540883d":
static cleanup __amd64 void CSurface::GL_ForceAntialias(bool on);
"!.554889e54881ec80000000488b05????1e00488b00":
static cleanup __amd64 bool CSurface::GL_DrawLine(float x1, float y1, float x2, float y2, float lineWidth, GL_Color color);
"!.554889e54883ec60":
static cleanup __amd64 bool CSurface::GL_DrawTriangle(Point vertex1, Point vertex2, Point vertex3, GL_Color color);
"!.554889e54881ec80000000488b05????1e00488b00":
static cleanup __amd64 bool CSurface::GL_DrawRect(float x1, float y1, float x2, float y2, GL_Color color);
"!.554889e54881eca0":
static cleanup __amd64 bool CSurface::GL_DrawRectOutline(int x1, int y1, int x2, int y2, GL_Color color, float lineWidth);
".554889e54157415653":
static cleanup __amd64 bool CSurface::GL_DrawCircle(int x, int y, float radius, GL_Color color);
".554889e54157415653":
static cleanup __amd64 bool CSurface::GL_DrawEllipse(int x, int y, int a1, int b1, GL_Color color);
".554889e5415741564155415453":
static cleanup __amd64 bool CSurface::GL_DrawLaser(int x, int y, int w, int h, GL_Color color);
".554889e541574156415453":
static cleanup __amd64 bool CSurface::GL_DrawShield(int x, int y, float a1, float b1, int angle1, int angle2, GL_Color color, float thickness);
"!.415f5dc3":
noHook __amd64 void CSurface::NoHook();
"!.554889e5":
static cleanup __amd64 bool CSurface::GL_BlitImage(GL_Texture* tex, float x, float y, float x2, float y2, float rotation, GL_Color color, bool mirror);
"!.55":
noHook __amd64 bool CSurface::GL_BlitImageCommon();
"!.5548":
static cleanup __amd64 bool CSurface::GL_BlitPixelImage(GL_Texture* tex, float x, float y, float x2, float y2, float rotation, GL_Color color, bool mirror);
".0f1f": // Not eligible for hooking ONLY execute. This address starts in the NOP padding of the previous function
static cleanup __amd64 bool CSurface::GL_BlitImagePartial(GL_Texture* tex, float x, float y, float size_x, float size_y, float start_x, float end_x, float start_y, float end_y, float alpha, GL_Color color, bool mirror);
".554889e5415741564155415453":
static cleanup __amd64 bool CSurface::GL_BlitPixelImageWide(GL_Texture* tex, float x, float y, int x2, int y2, float opacity, GL_Color color, bool mirror);
".554889e54157415641554154534883ec5849":
static cleanup __amd64 void CSurface::GL_BlitMultiImage(GL_Texture* tex, const std::vector<GL_TexVertex>& texVertices, bool antialias);
".554889e54157415641554154534883ec5849":
static cleanup __amd64 void CSurface::GL_BlitMultiColorImage(GL_Texture* tex, const std::vector<GL_ColorTexVertex>& texVertices, bool antialias);
"!.554889e50f2805????16000f28c85d":
static cleanup __amd64 void CSurface::GL_RenderPrimitive(GL_Primitive* primitive);
"!.554889e5":
static cleanup __amd64 void CSurface::GL_RenderPrimitiveWithAlpha(GL_Primitive* primitive, float alpha);
".554889e54156534883ec104889fb4885":
static cleanup __amd64 void CSurface::GL_RenderPrimitiveWithColor(GL_Primitive* primitive, GL_Color color);
".554889e553504889":
static cleanup __amd64 void CSurface::GL_DestroyPrimitive(GL_Primitive* primitive);
".554889e55348":
noHook __amd64 void CSurface::GL_CreateTrianglePrimitive();
".554889e55348":
static cleanup __amd64 GL_Primitive* CSurface::GL_CreateRectPrimitive(float x, float y, float w, float h, GL_Color color);
".554889e541574156415453":
static cleanup __amd64 GL_Primitive* CSurface::GL_CreateMultiRectPrimitive(std::vector<Globals::Rect>& vec, GL_Color color);
".554889e5534881eca8000000":
static cleanup __amd64 GL_Primitive* CSurface::GL_CreateRectOutlinePrimitive(int x, int y, int w, int h, GL_Color color, float lineWidth);
".5548":
static cleanup __amd64 GL_Primitive* CSurface::GL_CreateMultiLinePrimitive(std::vector<GL_Line>& vec, GL_Color color, float thickness);
".554889e541574156":
noHook __amd64 void CSurface::GL_CreateCirclePrimitive();
".554889e541":
static cleanup __amd64 GL_Primitive* CSurface::GL_CreatePiePartialPrimitive(int x, int y, float radius, float deg1, float deg2, float thickness, GL_Color color);
".554889e541574156534883ec38f3":
static cleanup __amd64 GL_Primitive* CSurface::_CreateImagePrimitive(GL_Texture *tex, float x, float y, float size_x, float size_y, float u0, float v0, float u1, float v1, GL_Color color, float rotate);
".554889e54156534883ec60":
static cleanup __amd64 GL_Primitive* CSurface::GL_CreateImagePartialPrimitive(GL_Texture* tex, float x, float y, float size_x, float size_y, float start_x, float end_x, float start_y, float end_y, float alpha, GL_Color color, bool mirror);
".4889f0488b08488b":
static cleanup __amd64 GL_Primitive* CSurface::GL_CreateMultiImagePrimitive(GL_Texture* tex, std::vector<GL_TexVertex>* vec, GL_Color color);
".554889e54156534883ec204989fe498b06498b5e":
static cleanup __amd64 void CSurface::AddTexVertices(std::vector<GL_TexVertex>* vec, float x1, float y1, float u1, float v1, float x2, float y2, float u2, float v2);


struct CSurface depends (GL_Primitive)
{{
	/*
	// Could actually use the reimplemented function here but decided not to for simplicity
	inline static GL_Primitive* CSurface::CreateImagePrimitive(GL_Texture *tex, float x, float y, float size_x, float size_y, float u0, float v0, float u1, float v1, GL_Color color, float rotate)
	{
		std::vector<GL_TexVertex> vertices;
		vertices.resize(4);

		// Set up the 4 vertices with custom texture coordinates
		vertices[0] = {x, y, u0, v0};					// Bottom-left
		vertices[1] = {x + size_x, y, u1, v0};		   // Bottom-right  
		vertices[2] = {x + size_x, y + size_y, u1, v1};  // Top-right
		vertices[3] = {x, y + size_y, u0, v1};		   // Top-left

		if (rotate != 0.f)
		{
			float sinRotate = sinf(rotate);
			float cosRotate = cosf(rotate);
			float halfWidth = size_x * 0.5f;
			float halfHeight = size_y * 0.5f;
			float centerX = x + halfWidth;
			float centerY = y + halfHeight;

			// Pre-calculate rotation components
			float rotatedHalfWidthX = cosRotate * -halfWidth;
			float rotatedHalfWidthY = -halfWidth * sinRotate;
			float rotatedHalfHeightX = -halfHeight * cosRotate;
			float rotatedHalfHeightY = sinRotate * halfHeight;

			// Rotate each vertex around the center
			vertices[0].x = rotatedHalfWidthX + rotatedHalfHeightY + centerX;
			vertices[0].y = rotatedHalfWidthY + rotatedHalfHeightX + centerY;

			vertices[1].x = rotatedHalfHeightY + cosRotate * halfWidth + centerX;
			vertices[1].y = rotatedHalfHeightX + sinRotate * halfWidth + centerY;

			vertices[2].x = (cosRotate * halfWidth - rotatedHalfHeightY) + centerX;
			vertices[2].y = sinRotate * halfWidth + cosRotate * halfHeight + centerY;

			vertices[3].x = rotatedHalfWidthX - rotatedHalfHeightY + centerX;
			vertices[3].y = rotatedHalfWidthY + cosRotate * halfHeight + centerY;
		}

		GL_Primitive* primitive = LowCreateImagePrimitive(tex, &vertices, color);
		return primitive;
	}
	*/

	static GL_Primitive* GL_CreatePixelImagePrimitive(GL_Texture *tex, float x, float y, float size_x, float size_y, float rotate, GL_Color color, bool mirrored)
	{
		if (1.f < color.r || 1.f < color.g || 1.f < color.b)
		{
			color.r = color.r / 255.f;
			color.g = color.g / 255.f;
			color.b = color.b / 255.f;
		}

		// Determine texture coordinates based on mirroring
		float u0, u1;
		if (mirrored)
		{
			u0 = 1.f;  // Mirrored: start from right side of texture
			u1 = 0.f;  // Mirrored: end at left side of texture
		}
		else
		{
			u0 = 0.f;  // Normal: start from left side of texture
			u1 = 1.f;  // Normal: end at right side of texture
		}

		// De-Inlined CreateImagePrimitive(GL_Texture *tex, float x, float y, float size_x, float size_y, float u0, float v0, float u1, float v1, GL_Color color, float rotate)
		return _CreateImagePrimitive(tex, x, y, size_x, size_y, u0, 0.f, u1, 1.f, color, rotate);
	}

	static GL_Primitive* GL_CreateImagePrimitive(GL_Texture* tex, float x, float y, float size_x, float size_y, float rotate, GL_Color color)
	{
		// De-Inlined CreatePixelsImagePrimitive(GL_Texture *tex, float x, float y, float size_x, float size_y, float rotate, GL_Color color, bool mirrored)
		GL_Primitive* primitive = GL_CreatePixelImagePrimitive(tex, x, y, size_x, size_y, rotate, color, false);
		primitive->textureAntialias = true;
		return primitive;
	}


	/*
	static void GL_ApplyShader(int pipeline)
	{
		shader_pipeline_apply(pipeline);
	}
	
	static void GL_DestroyShader(int pipeline)
	{
		shader_pipeline_destroy(pipeline);
	}
	
	static int GL_CreateShaderPipeline(int vertex_shader, int fragment_shader)
	{
		return shader_pipeline_create(vertex_shader, fragment_shader);
	}
	
	static int GL_CreateShader(ShaderType type, const char* source)
	{
		return shader_create_from_source(type, source, -1);
	}
	*/
	
}};
